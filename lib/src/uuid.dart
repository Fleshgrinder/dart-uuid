// This is free and unencumbered software released into the public domain.

import 'dart:math';

import 'package:convert/convert.dart';
import 'package:crypto/crypto.dart';
import 'package:uuid/uuid.dart';

String _fmt(int i) => hex.encode([i]).padLeft(2, '0');

/// Universally Unique Identifier
class Uuid implements Comparable<Uuid> {
  /// A 128 bit (16 bytes) buffer containing the UUID.
  final List<int> bytes;

  /// The Domain Name System (DNS) Namespace UUID
  ///
  /// - [RFC 4122 Appendix C](https://tools.ietf.org/html/rfc4122#appendix-C)
  /// - [Wikipedia: Domain Name System](https://en.wikipedia.org/wiki/Domain_Name_System)
  static const Uuid namespaceDns = const Uuid._(const [
    0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1,
    0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8,
  ]);

  /// The Object Identifier (OID) Namespace UUID
  ///
  /// - [RFC 4122 Appendix C](https://tools.ietf.org/html/rfc4122#appendix-C)
  /// - [Wikipedia: Object Identifier](https://en.wikipedia.org/wiki/Object_identifier)
  static const Uuid namespaceOid = const Uuid._(const [
    0x6b, 0xa7, 0xb8, 0x12, 0x9d, 0xad, 0x11, 0xd1,
    0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8,
  ]);

  /// The Uniform Resource Locator (URL) Namespace UUID
  ///
  /// - [RFC 4122 Appendix C](https://tools.ietf.org/html/rfc4122#appendix-C)
  /// - [Wikipedia: URL](https://en.wikipedia.org/wiki/URL)
  static const Uuid namespaceUrl = const Uuid._(const [
    0x6b, 0xa7, 0xb8, 0x11, 0x9d, 0xad, 0x11, 0xd1,
    0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8,
  ]);

  /// The X.500 Distinguished Names (X.500 DN) Namespace UUID
  ///
  /// Both DER and text format can be hashed in this namespace.
  ///
  /// - [RFC 4122 Appendix C](https://tools.ietf.org/html/rfc4122#appendix-C)
  /// - [Wikipedia: X.500](https://en.wikipedia.org/wiki/X.500)
  /// - [Wikipedia: Lightweight Directory Access Protocol](https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol)
  static const Uuid namespaceX500 = const Uuid._(const [
    0x6b, 0xa7, 0xb8, 0x14, 0x9d, 0xad, 0x11, 0xd1,
    0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8,
  ]);

  /// The special nil UUID that has all 128 bits set to zero.
  ///
  /// - [RFC 4122 Section 4.1.7](https://tools.ietf.org/html/rfc4122#section-4.1.7)
  /// - [Wikipedia: Nil UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier#Nil_UUID)
  static const Uuid nil = const Uuid._(const [
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  ]);

  const Uuid._(this.bytes);

  /// Construct new UUID instance from binary string of exactly 16 bytes.
  ///
  /// Any string of 16 bytes is accepted by this named constructor. This
  /// enables the construction of UUIDs of any variant and version, regardless
  /// of the [Uuid.parse] implementation.
  ///
  ///       final Uuid uuid = new Uuid.fromBinary('\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00');
  ///       assert(uuid == Uuid.nil);
  factory Uuid.fromBinary(String binary) =>
      new Uuid.fromBytes(binary.codeUnits);

  /// Construct new UUID instance from a list of exactly 16 bytes.
  factory Uuid.fromBytes(List<int> bytes) {
    if (bytes.length < 16)
      throw new ArgumentError(
        'Expected exactly 16 bytes, but got ${bytes.length}'
      );

    for (final int i in bytes)
      RangeError.checkValueInInterval(i, 0, 0xff);

    return new Uuid._(bytes);
  }

  /// Create new MD5 hashed namespace/name based UUID.
  ///
  /// > RFC 4122 recommends [Uuid.v5] over this one and states that version 3
  /// > UUIDs should be used if backwards compatibility is required only. This
  /// > is because MD5 has a higher collision probability compared to SHA1,
  /// > which is used by version 5; regardless of the truncation!
  ///
  /// Version 3 UUIDs are generated by MD5 hashing the concatenated
  /// namespace's binary representation and the given name. The namespace
  /// itself must be another UUID. This can be any UUID, or one of the
  /// predefined ones:
  ///
  /// - [Uuid.namespaceDns]
  /// - [Uuid.namespaceOid]
  /// - [Uuid.namespaceUrl]
  /// - [Uuid.namespaceX500]
  ///
  /// A particular name within the same namespace always results in the same
  /// version 3 UUID, across all RFC 4122 compliant implementations. However,
  /// the namespace and name cannot be determined from the UUID alone.
  ///
  ///     final Uuid uuid = new Uuid.v3(Uuid.namespaceDns, 'dartlang.org');
  ///
  ///     assert(uuid.isNil == false);
  ///     assert(uuid.variant == UuidVariant.rfc4122);
  ///     assert(uuid.version == UuidVersion.md5);
  ///     assert(uuid.toString() == '');
  ///     assert(uuid == new Uuid.v3(Uuid.namespaceDns, 'dartlang.org'));
  ///
  /// - [RFC 4122 Section 4.3](https://tools.ietf.org/html/rfc4122#section-4.3)
  /// - [Wikipedia: Version 3 UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier#Versions_3_and_5_.28namespace_name-based.29)
  factory Uuid.v3(Uuid namespace, String name) =>
      new Uuid._(md5.convert('${namespace.toBinary()}$name'.codeUnits).bytes)
          .withVariant(UuidVariant.rfc4122)
          .withVersion(UuidVersion.md5);

  /// Create new random UUID.
  ///
  /// Version 4 UUIDs are randomly generated from the best available random
  /// source (see [Random.secure]). Some systems may not be able to generate
  /// sufficient entropy, e.g. virtual machines. This might lead to collisions
  /// faster than desired. If this is the case, the [Uuid.v5] should be used
  /// instead.
  ///
  ///     final Uuid uuid = new Uuid.v4();
  ///
  ///     assert(uuid.isNil == false);
  ///     assert(uuid.variant == UuidVariant.rfc4122);
  ///     assert(uuid.version == UuidVersion.random);
  ///     assert(uuid != new Uuid.v4());
  ///
  /// - [RFC 4122 Section 4.4](https://tools.ietf.org/html/rfc4122#section-4.4)
  /// - [Wikipedia: Version 4 UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_.28random.29)
  factory Uuid.v4() {
    final Random r = new Random.secure();

    return new Uuid._(new List.generate(16, (_) => r.nextInt(0xff)))
        .withVariant(UuidVariant.rfc4122)
        .withVersion(UuidVersion.random);
  }

  /// Create new SHA-1 hashed namespace/name based UUID.
  ///
  /// Version 5 UUIDs are generated by SHA-1 hashing the concatenated
  /// namespace's binary representation and the given name. The namespace
  /// itself must be another UUID. This can be any UUID, or one of the
  /// predefined ones:
  ///
  /// - [Uuid.namespaceDns]
  /// - [Uuid.namespaceOid]
  /// - [Uuid.namespaceUrl]
  /// - [Uuid.namespaceX500]
  ///
  /// A particular name within the same namespace always results in the same
  /// version 5 UUID, across all RFC 4122 compliant implementations. However,
  /// the namespace and name cannot be determined from the UUID alone.
  ///
  ///     final Uuid uuid = new Uuid.v5(Uuid.namespaceDns, 'dartlang.org');
  ///
  ///     assert(uuid.isNil == false);
  ///     assert(uuid.variant == UuidVariant.rfc4122);
  ///     assert(uuid.version == UuidVersion.sha1);
  ///     assert(uuid.toString() == '');
  ///     assert(uuid == new Uuid.v5(Uuid.namespaceDns, 'dartlang.org'));
  ///
  /// - [RFC 4122 Section 4.3](https://tools.ietf.org/html/rfc4122#section-4.3)
  /// - [Wikipedia: Version 5 UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier#Versions_3_and_5_.28namespace_name-based.29)
  factory Uuid.v5(Uuid namespace, String name) =>
      new Uuid._(sha1.convert('${namespace.toBinary()}$name'.codeUnits).bytes)
          .withVariant(UuidVariant.rfc4122)
          .withVersion(UuidVersion.sha1);

  /// Parse the given input as UUID.
  ///
  /// The following UUID representations are parsable:
  ///
  /// - hexadecimal (`00000000111122223333444444444444`),
  /// - string (`00000000-1111-2222-3333-444444444444`),
  /// - URNs (`urn:uuid:00000000-1111-2222-3333-444444444444`), and
  /// - Microsoft (`{00000000-1111-2222-3333-444444444444}`).
  ///
  /// Whitespace (`\s`), braces (`{` and `}`), as well as hyphens (`-`) are
  /// ignored in the input. The parsing algorithm follows the
  /// [robustness principle] and ist not meant for validation.
  ///
  ///     // Parsing of canonical representations
  ///     Uuid.parse('0123456789abcdef0123456789abcdef');
  ///     Uuid.parse('01234567-89ab-cdef-0123-456789abcdef');
  ///     Uuid.parse('urn:uuid:01234567-89ab-cdef-0123-456789abcdef');
  ///     Uuid.parse('{01234567-89ab-cdef-0123-456789abcdef}');
  ///
  ///     // Leading and trailing garbage is ignored.
  ///     Uuid.parse(' \t ---- { urn:uuid:----0123-{4567}-89ab-{cdef}-0123-4567-89ab-cdef---- } ---- \t ');
  ///
  /// [robustness principle]: https://en.wikipedia.org/wiki/Robustness_principle
  static Uuid parse(String input) {
    String str = input.replaceAll(new RegExp(r'[\s{}-]+'), '');

    if (str.startsWith('urn:uuid:')) {
      str = str.replaceFirst('urn:uuid:', '');
    }

    if (str.length != 32) {
      if (str.length > 32) {
        throw new UuidParseException.tooLong(input, str.length);
      }
      throw new UuidParseException.tooShort(input, str.length);
    }

    try {
      return new Uuid._(hex.decode(str));
    } on FormatException catch (e) {
      throw new UuidParseException.fromFormatException(input, e);
    }
  }

  /// Whether this is the special nil UUID, or not.
  bool get isNil => bytes == new List.filled(16, 0);

  @override
  int get hashCode => int.parse('0x${toHex()}');

  /// The variant that specifies the internal data layout.
  ///
  /// This implementation generates [UuidVariant.rfc4122] UUIDs only, however,
  /// parsing and construction of other variants is supported. Note that the
  /// variant might not be meaningful if the UUID was created from a
  /// non-compliant generator.
  UuidVariant get variant {
    if (bytes[8] & 0x80 == 0x00) return UuidVariant.ncs;
    if (bytes[8] & 0xc0 == 0x80) return UuidVariant.rfc4122;
    if (bytes[8] & 0xe0 == 0xc0) return UuidVariant.microsoft;
    if (bytes[8] & 0xe0 == 0xe0) return UuidVariant.future;

    return null;
  }

  /// The version that specifies the generation algorithm.
  ///
  /// Note that the version might not be meaningful if the UUID was created
  /// from a non-compliant generator.
  UuidVersion get version => UuidVersion.values[bytes[6] >> 4];

  bool operator <(Uuid other) => other.hashCode < hashCode;

  bool operator <=(Uuid other) => other.hashCode <= hashCode;

  @override
  bool operator ==(Object other) =>
      other is Uuid && bytes.every(other.bytes.contains);

  bool operator >(Uuid other) => other.hashCode > hashCode;

  bool operator >=(Uuid other) => other.hashCode >= hashCode;

  int operator [](int index) => bytes[index];

  @override
  int compareTo(Uuid other) {
    if (other.hashCode < hashCode) return -1;
    if (other.hashCode > hashCode) return 1;
    return 0;
  }

  /// Convert to binary representation
  String toBinary() => bytes.fold('', (p, e) => '$p${new String.fromCharCode(e)}');

  /// Convert to hexadecimal representation
  String toHex() => bytes.fold('', (p, e) => '$p${_fmt(e)}');

  /// Convert to string representation
  ///
  /// The string representation of a UUID are 32 hexadecimal digits separated
  /// by a hyphen into five groups of 8, 4, 4, 4, and 12 digits. The
  /// hexadecimal digits `a` through `f` are always formatted as lower case
  /// characters, in accordance with RFC 4122.
  ///
  ///     assert(Uuid.namespaceDns.toString() == '6ba7b810-9dad-11d1-80b4-00c04fd430c8');
  ///
  /// - [RFC 4122 Page 4](https://tools.ietf.org/html/rfc4122#page-4)
  /// - [Wikipedia: UUID Format](https://en.wikipedia.org/wiki/Universally_unique_identifier#Format)
  @override
  String toString() {
    int offset = 0;

    String f(int c) {
      final String result = bytes.skip(offset).take(c).fold('', (p, e) => '$p${_fmt(e)}');
      offset += c;
      return result;
    };

    return '${f(4)}-${f(2)}-${f(2)}-${f(2)}-${f(6)}';
  }

  Uri toUrn() => new Uri(scheme: 'urn', path: 'uuid:${toString()}');

  Uuid withVariant(UuidVariant variant) {
    final List<int> bytes = this.bytes;

    if (variant == UuidVariant.rfc4122)
      bytes[8] = (bytes[8] & 0x3f) | 0x80;
    else if (variant == UuidVariant.microsoft)
      bytes[8] = (bytes[8] & 0x1f) | 0xc0;
    else if (variant == UuidVariant.ncs)
      bytes[8] &= 0x7f;
    else
      bytes[8] = (bytes[8] & 0x1f) | 0xe0;

    return new Uuid._(bytes);
  }

  Uuid withVersion(UuidVersion version) {
    final List<int> bytes = this.bytes;

    bytes[6] = (bytes[6] & 0x0F) | (version.index << 4);

    return new Uuid._(bytes);
  }
}
